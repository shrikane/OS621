\documentclass[12pt, conference, compsocconf]{IEEEtran}
\usepackage{cite}
\usepackage{algorithmic}
\usepackage{url}
\usepackage{graphicx}

\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{CMSC 621 Erlang Project Report}


% author names and affiliations
% use a multiple column layout for up to two different
% affiliations

\author{
\IEEEauthorblockN{Yin Huang, Anuja Kench, Shrinivas Kane, and Abhishek Sethi}
\IEEEauthorblockA{Professor: Kontas Kalpakis \\
University of Maryland, Baltimore County\\
Computer Science and Electrical Engineering\\
{\{yhuang9, akench1, skane3@umbc.edu\}}
}
%\and
%%\IEEEauthorblockN{Han Dong}
%\IEEEauthorblockA{line 1 (of Affiliation): dept. name of organization\\
%line 2: name of organization, acronyms acceptable\\
%line 3: City, Country\\
%line 4: Email: name@xyz.com}
}

% conference papers do not typically use \thanks and this command
% is locked out in conference mode. If really needed, such as for
% the acknowledgment of grants, issue a \IEEEoverridecommandlockouts
% after \documentclass

% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
% 
%\author{\IEEEauthorblockN{Michael Shell\IEEEauthorrefmark{1},
%Homer Simpson\IEEEauthorrefmark{2},
%James Kirk\IEEEauthorrefmark{3}, 
%Montgomery Scott\IEEEauthorrefmark{3} and
%Eldon Tyrell\IEEEauthorrefmark{4}}
%\IEEEauthorblockA{\IEEEauthorrefmark{1}School of Electrical and Computer Engineering\\
%Georgia Institute of Technology,
%Atlanta, Georgia 30332--0250\\ Email: see http://www.michaelshell.org/contact.html}
%\IEEEauthorblockA{\IEEEauthorrefmark{2}Twentieth Century Fox, Springfield, USA\\
%Email: homer@thesimpsons.com}
%\IEEEauthorblockA{\IEEEauthorrefmark{3}Starfleet Academy, San Francisco, California 96678-2391\\
%Telephone: (800) 555--1212, Fax: (888) 555--1212}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}Tyrell Inc., 123 Replicant Street, Los Angeles, California 90210--4321}}

\maketitle




% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



\section{Introduction}
\indent Our implementation of Gossip-based aggregation and data update and retrieval in Erlang aims at performing the following four computational tasks as required in the project description. \\
\indent A single large file $F$ with floating-point numbers have been split into $M$ fragments $F_1$, $F_2$, â€¦, $F_M$ which have been placed at various nodes of the system. Each fragment is placed at one or more nodes.
\begin{itemize}
	\item Compute the minimum (min) and maximum (max) value in F and store them at Node $1$.
	\item Compute the average (avg) of the values in F and store it at all the nodes.
	\item Update the contents of fragment $i$ at each node that may have a copy of it. 
	\item Retrieve the contents of fragment $i$ from any node that may have an up-to-date copy of it. 
\end{itemize}
\indent Two types of network are simulated with two virtual machines hosted on two different laptops:
\begin{itemize}
	\item Ring 
	\item Mesh
\end{itemize}
\indent In our implementation, we define a node as an Erlang process with process name $P_\sharp$ and each node stores its fragments $F_\sharp$.  Every node maintains a neighbor node list. This list differs as in these two types of networks. However the gossip mechanism are the same. A computational task request is initialized at node $1$, and node $1$ will start spreading out the request to its neighbors. Whenever a neighbor node receives a request, this node will first exchange information with the requesting node, and then spread the request to its neighbors.  In such a way this request will eventually reach out to the whole network. In order to pick a neighbor, we use a random number generator to pick a node from the neighbor list. Meanwhile, the user can specify the number of iterations for every node to send out the gossip. \\
\indent The report is organized in the following sections: Section II explains the gossip algorithm, Section III focuses on the min, max, avg, read and write operation. Section IV demonstrates the research results. Section V is the analysis and discussion, followed by conclusion and future work in Section VI and Section VII.  

\section{Gossip algorithm  }
\indent In large distributed, heterogeneous networks, applications are asking for a set of functions that provide components of a distributed system access to global information such as network size, average load etc. Gossip-based aggregation protocol works in a fully decentralized manner where all nodes exchange the local information with its neighbors and thus infer the global information. There are two types of protocols, reactive and proactive protocols. We focus on the proactive protocol which pushes the query from any issuer to all nodes in the system.   \\
\indent We use asynchronous push-pull gossip protocol in our implementation. The task of a proactive protocol is to continuously provide all nodes with an up-to-date information held by current set of nodes. Two services are provided in each node, one is to receive request, the other go update information and send out the new information.  \\
\indent Every node maintains a neighbor list as its neighbor nodes. Whenever a node receives a request message, it will randomly pick up a node in the neighbor list, and forward the request. We set up a threshold parameter named Itr to determine the number of iterations. So the gossip for each node will be executing Itr times. We will report our convergence ratio in our result section with regard to the size of the network, topology of the network, and the size of the file, number of segmentation of the file etc. 

\section{Computation implementations}
 \subsection{Min, Max, Avg implementation}
Anuja, could you please articulate this section? Thanks.
 \subsection{Update and retrieval}
\indent We have wrapped both the read and write operation in a single process called Update(). The reason to put these two operations in the same process is to avoid the problems incurred by multiple accesses to the same file. Update() will only execute either write or read to the segmentation. Since Erlang has the FIFO mailbox, we simply utilize this mailbox as a job request queue. This approach, however, sacrifices the consistency since we fail to ensure the write update has been done successfully to all replicas. This is a trade-off in a gossip-based approach since we have no the information regarding the locations of replicas. \\
\indent Whenever a process receives a write or read message, the process will check its own data directory to see if it contains the target segmentation. For write operation, if the process contains the segmentation, it will continue and update the segmentation, else it will pick a random neighbor and forward the request. For read operation, if the process contains the segmentation, it will reply the values of the segmentation to the request node, otherwise it will forward the request to its neighbor. We have two operation modes: a. synchronized b. non-synchronized. In Synchronized case, the request node will wait for all replies for target nodes until it stops gossiping. In non-synchronized case, the request node will not wait for any replies but rather work on other things. The synchronized case gives better consistency while the non-synchronized has better performance (time response). The former is more complicated than the latter. \\
\indent In our implementation, we take the non-synchronized mode where the write request is sent out and gossip a fixed number of iterations while the read request is only waiting for the first reply from any matching node that has the segmentation.
The advantage of such design is that we can guarantee that no race condition for the file will occur, hence a higher accuracy. The disadvantage is the response latency because every time only one node is allowed to do operation on the fragmentation. \\
\indent Another problem with this design is that we are not able to guarantee that a read request will always get the latest version, current implementation only accepts the first response without checking the replies from other nodes. Solution to this problem comes in the following directions. First, we could maintain a list of replicas for each fragmentation, when update the fragmentation, we send out update requests to all these nodes holding the fragmentation and wait for acknowledgement. We call this schema write-to-all and read-once. The problem with this solution is the high latency for the update operation. Also we need global information about the nodes that hold the replicas. Second, we could use a vector to record the number of updates for each fragmentation, and read the reply with the highest number.  

\section{Experimental results} 
\indent This sections needs inputs
\section{Analysis and discussion}
\begin{itemize}
	\item To solve the consistency problem, we need to adopt a quorum-based approach to access the same fragmentation, for the replicas, we also need such information stored in a master node which initializes the file distribution. This global information, however, defeats the purpose of gossip approach in the first place. Alternatively, we could use gossip message exchange to find the replicas for each segmentation, and build this global replica table for all nodes.  
\end{itemize}
\section{Conclusion}
\indent In this project, we have successfully implemented Gossip-based aggregation and data update and retrieval for a large distributed system using Erlang. The three computational tasks have been demonstrated in terms of efficiency, effectiveness and accuracy. We have compared the convergence performance of gossip in different types of networks, say ring and mesh, and different sizes of networks. 

\section{Future work}
\begin{itemize}
	\item Implement quorum-based approach to deal with the mutual exclusion problem caused by multiple access to the same fragmentations. 
	\item Deal with node failure and message loss by setting time outs. 
	\item Please feel free to add your thoughts
\end{itemize}
% conference papers do not normally have an appendix



% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
%\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
\begin{thebibliography}{1}


\end{thebibliography}




% that's all folks
\end{document}


